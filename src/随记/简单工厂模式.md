# 简单工厂模式

简单工厂模式又叫做静态工厂方法模式，他属于类创建型模式。
在简单工厂模式中，定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式将所有的实例创建集中到简单工厂类中进行，将创建对象获取实例的代码从应用代码中抽离，而是在简单工厂类的静态方法中处理创建对象的细节，如果创建的实例有扩展和改变，只需更新简单工厂类即可。

但由于使用静态方法来获取对象，使其不能在运行期间通过不同方式去动态改变创建行为，因此存在一定局限性。

结构
简单工厂类（SimpleFactory）：提供一个静态获取实例方法（getInstance），返回符合需求的品牌实例。

```java
public class SimpleFactory {
    private static final String ADIDAS = "Adidas";
    private static final String NIKE = "Nike";
    private static final String DONG_FENG = "DongFeng";
    private static final String HONG_QI = "HongQi";

    /**
     * 根据品牌英文名称获取各品牌实例对象
     * @param englishName
     * @return
     */
    public static Brand getInstance(String englishName){

        if(ADIDAS.equals(englishName)){
            return new Adidas();
        }else if(NIKE.equals(englishName)){
            return new Nike();
        }else if(DONG_FENG.equals(englishName)){
            return new DongFeng();
        }else if(HONG_QI.equals(englishName)){
            return new HongQi();
        }else {
            throw new RuntimeException(englishName+ "未能匹配到实例化对象！");
        }

    }
}
```

抽象品牌工厂（Brand）：所有品牌的父类，所有子类（品牌对象）都需要继承它， 它封装了各种品牌对象的共有方法 。

```java
public abstract class Brand {    
    /**
    * 获取品牌的名称
    * @return     
    */   		
    public abstract String getName();
}
```

品牌实例（Adidas，DongFeng，HongQi，Nike）：

```java
public class Adidas extends Brand{    
    @Override
    public String getName() {
        return "阿迪达斯";
    }
}
public class DongFeng extends Brand {
    @Override
    public String getName() {
        return "东风";
    }
}
```


进行测试

```java
public static void main(String[] args) {
    Brand brand = SimpleFactory.getInstance(ADIDAS);
    System.out.println("创建的实例为:" + brand.getName());
}
创建的实例为:阿迪达斯
```

优缺点
简单工厂模式实现了生成产品类的代码跟客户端分离，在工厂类里面可以添加所需生成产品的逻辑。缺点是每次增加一种实例，都需要修改工厂类，不符合开闭原则 

