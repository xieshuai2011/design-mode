原型设计模式

原型模式就是一种对象的创建方式，就好比克隆技术一样，将已存在的对象实例复制一份创建新的实例。使用原型模式创建的实例和已存在的实例不仅结构相同，其中的数据也是一模一样的。

根据对象克隆深度层次的不同，有浅客隆，深克隆。

浅克隆：

```java
public class ShallowClone implements Cloneable{

    String name;
    String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public ShallowClone(String name, String sex) {
        this.name = name;
        this.sex = sex;
    }

    public ShallowClone() {
    }

    @Override
    public String toString() {
        return "ShallowClone{" +
                "name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                '}';
    }

    @Override
    protected ShallowClone clone() {
        try {
            return (ShallowClone) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        ShallowClone shallowClone = new ShallowClone("小马","男");
        ShallowClone clone = shallowClone.clone();
        System.out.println(shallowClone.toString());
        System.out.println(clone.toString());

    }
    ShallowClone{name='小马', sex='男'}
	ShallowClone{name='小马', sex='男'}
    原型模式.DeepClone@4554617c
	原型模式.DeepClone@74a14482
```

浅客隆在对象属性都是包装类型的情况下比较常用，其克隆的结果是数据和结构相同，但内存地址则不一样。



深克隆：

```java
public class User implements Serializable {
    String a;
    String b;

    public String getA() {
        return a;
    }

    public void setA(String a) {
        this.a = a;
    }

    public String getB() {
        return b;
    }

    public void setB(String b) {
        this.b = b;
    }

    public User() {
    }

    public User(String a, String b) {
        this.a = a;
        this.b = b;
    }
}
```

```java
public class DeepClone implements Cloneable{

    String name;
    String sex;
    User user;

    @Override
    public String toString() {
        return "DeepClone{" +
                "name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", user=" + user +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public DeepClone() {
    }

    public DeepClone(String name, String sex, User user) {
        this.name = name;
        this.sex = sex;
        this.user = user;
    }

    @Override
    protected DeepClone clone(){
        try {
            DeepClone clone = (DeepClone) super.clone();
            User user = new User();
            user.setA(clone.getUser().getA());
            user.setB(clone.getUser().getB());
            clone.setUser(user);
            return clone;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        User user = new User("a","b");
        DeepClone deepClone = new DeepClone("小马","男",user);
        DeepClone clone = deepClone.clone();
        System.out.println(deepClone);
        System.out.println(clone);
    }
}
DeepClone{name='小马', sex='男', user=原型模式.User@4554617c}
DeepClone{name='小马', sex='男', user=原型模式.User@74a14482}
```

深克隆的结果和浅克隆相似，结构，数据相同。
但是因为对象中有引用对象（user），所以用浅克隆的话会造成这个引用对象的内存地址不改变，这样的话就意味着克隆与被克隆的对象都共享着对象中的引用对象，这就变得不安全了，因为在克隆了此对象后都可以对其引用对象进行修改。

所以我们可以先将user对象拿出来，重新创建一个然后存进去，这样他们就有了属于自己的内存地址不再相互干扰了。
除了上面这样的办法还有一种用对象的序列化和反序列化来重建对象，也可以达到深克隆的目的。

```java
public class DeepClone implements Cloneable, Serializable {

    String name;
    String sex;
    User user;

    @Override
    public String toString() {
        return "DeepClone{" +
                "name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", user=" + user +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public DeepClone() {
    }

    public DeepClone(String name, String sex, User user) {
        this.name = name;
        this.sex = sex;
        this.user = user;
    }

    @Override
    protected DeepClone clone(){
        try {
            DeepClone clone = (DeepClone) super.clone();
            try {
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                ObjectOutputStream oos = new ObjectOutputStream(bos);
                oos.writeObject(clone.getUser());
                ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
                ObjectInputStream ois = new ObjectInputStream(bis);
                User user = (User) ois.readObject();
                clone.setUser(user);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return clone;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        User user = new User("a","b");
        DeepClone deepClone = new DeepClone("小马","男",user);
        DeepClone clone = deepClone.clone();
        System.out.println(deepClone);
        System.out.println(clone);
    }
}
```

 这中方式的不同之处在于需要参与克隆的对象全部实现Serializable类来进行序列化反序列化。

final 类型修饰的成员变量不能进行深度拷贝。

原型模式的一个重点就是重写克隆的方法（ clone()），还有就是需要实现 Cloneable 类，这是对象可以被克隆的标记，类中并没有方法。

在对象被克隆的时候，类的构造函数是不会被执行的。因为克隆的原理是在内存中（对象一般放在堆内存中）以二进制的形式进行克隆，重新分配一块内存进行存储，而类的构造函数也就没有执行了。

