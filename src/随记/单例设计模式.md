# 单例设计模式

 单例模式的概要就是确保一个类只有一个实例，并提供一个全局访问点。 

##### 懒汉式单例：

 对于实例做懒加载处理，即在客户第一次使用时再做创建，所以第一次获取实例的效率会稍微低一些。 

```java
	/**
     * 将自身实例化对象设置为一个属性，并用static修饰
     */
    private static LazySingleton instance;

    /**
     * 静态方法返回该实例
     * @return
     */
    public static LazySingleton getInstance() {
        if(instance == null) {
            try {
                //为了使模拟效果更直观，这里延时1ms，具体看时序图
                TimeUnit.NANOSECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            instance = new LazySingleton();
        }
        return instance;
    }
```

懒汉模式的优缺点：
优点：延迟加载
缺点：不加同步的懒汉式是线程不安全的，加了synchronized之后就变成线程安全的了

```java
public class LazySingleton {
    /**
    * 将自身实例化对象设置为一个静态属性
    */
    private static LazySingleton instance;
    /**
    * 静态方法返回该实例
    * @return
    */
    public static LazySingleton getInstance() {
        if(instance == null) {
            try {
                //为了使模拟效果更直观，这里延时1ms
                TimeUnit.NANOSECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            instance = new LazySingleton();
        }
        return instance;
    }
    public synchronized static LazySingleton getInstanceSync(){
        if(instance == null){
            try {
                TimeUnit.MILLISECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            instance = new LazySingleton();
        }
        return instance;
    }
    public static void main(String[] args) throws InterruptedException {
        //模拟下多线程环境下实例可能不唯一的情况
        CountDownLatch startSignal = new CountDownLatch(1);
        for (int i = 0; i < 2; i++) {
            Thread t = new Thread(new MyThread(startSignal));
            t.setName("thread "+i);
            t.start();
        }
        Thread.sleep(1000);
        startSignal.countDown();
    }
    static class MyThread implements Runnable {
        private final CountDownLatch startSignal;
        public MyThread(CountDownLatch startSignal){
            this.startSignal = startSignal;
        }
        public void run() {
            try {
				System.out.println("current thread : " + 					Thread.currentThread().getName() + " is waiting.");
                startSignal.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            LazySingleton l = LazySingleton.getInstance();
            System.out.println(l);
        }
    }
}

current thread : thread 0 is waiting.
current thread : thread 1 is waiting.
单例模式.LazySingleton@6cc674dc
单例模式.LazySingleton@41672b2d
```



##### 饿汉式单例：

```java
public class HungrySingleton {
    private static final String CLASS_NAME = "HungrySingleton";
    private static final HungrySingleton instance = new HungrySingleton();
    static {
        //这里可以看到类加载后，优先加载上方的静态成员变量
        System.out.println("类加载时创建:"+instance);
    }
    private HungrySingleton(){
    }
    public static HungrySingleton getInstance(){
        return instance;
    }
    public static void main(String[] args) {
        System.out.println(HungrySingleton.CLASS_NAME);
        System.out.println("------------------");
        HungrySingleton a = HungrySingleton.getInstance();
        System.out.println(a);
        HungrySingleton b = HungrySingleton.getInstance();
        System.out.println(b);
    }
}
类加载时创建:单例模式.HungrySingleton@4554617c
HungrySingleton
------------------
单例模式.HungrySingleton@4554617c
单例模式.HungrySingleton@4554617c
```

这种获取单例的方式是线程安全的，JVM保障在多线程情况下一定先创建此实例并且只做一次实例化处理，但是这种情况没有做到懒加载，比如只是引用此类中的一个静态成员变量(常量)，此实例在类加载时也一起被初始化了，如果后续应用中不使用这个对象，则会造成资源浪费，占用内存。 

##### 双检锁机制：

 成员变量singleton最好使用volatile修饰，否则若在无参构造中初始化一个其他的成员变量，会产生指令重排序，导致新创建的对象获取不到最新的成员变量值。 

```java
public class DoubleCheckedLockingSingleton {
    /**
    * 将自身实例化对象设置为一个静态属性
    */
    private static volatile DoubleCheckedLockingSingleton singleton;
    /**
    * 构造私有化
    */
    private DoubleCheckedLockingSingleton(){}
    /**
    * 静态方法返回实例
    */
    public static DoubleCheckedLockingSingleton getInstance(){
        //检查是否被实例化
        if(singleton == null){
            synchronized (DoubleCheckedLockingSingleton.class){
                //某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象
                if (singleton == null){
                    singleton = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return singleton;
    }
}
```

 最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。 

##### 静态内部类单例模式

```java
/**
 * 以静态内部类的方式来创建获取单例对象
 *
 */
public class InnerSingleton {

    private InnerSingleton(){
    }
    
    public static InnerSingleton getInstance(){
        return InnerSingleton.InnerClass.instance;
    }
    //静态内部类内部加载的时候创建外部类，只加载一次，所以只创建一个
    static class InnerClass {
        private static InnerSingleton instance = new InnerSingleton();
    }
    
}
```

这种方式和懒汉式有些相似，它们都采用了类装载的机制来保证初始化实例时只有一个线程。 
将实例的初始化放到了静态类中去实现，从而实现了懒加载。 